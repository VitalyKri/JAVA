Класс (шаблон)  поля и методы
1. Название класса совпадает с именем файла.
2. Объекты располагаются в куче (heap)
3. new резервирует место в памяти и возвращает ссылку

new

this
    Ключевое слово this обращается к объекту
    this() к конструктору

Перегрузка конструктора происходит, когда создаем с новым набором параметров.




примитивные тип храниться в стеке


	                                                                                 private    default	    protected	    public
Один и тот же класс	                                                                    +	        +	        +	        +
Подкласс, производный от класса из того же самого пакета	                            -	        +	        +	        +
Класс из того же самого пакета, не являющийся подклассом	                            -	        +	        +	        +
Подкласс, производный от класса другого пакета	                                        -	        -	        +	        +
Класс из другого пакета, не являющийся подклассом, производный от класса данного пакета	-	        -	        -	        +


Модификаторы доступа
    1) Private — наиболее строгий модификатор доступа.
        Он ограничивает видимость данных и методов пределами одного класса.
    2) Default - Такие поля или методы видны всем классам в текущем пакете
    3) protected, будут видны:
       в пределах всех классов, находящихся в том же пакете, что и наш;
       в пределах всех классов-наследников нашего класса.
    4) public
        публичный, общедоступный класс или член класса.
        Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов

Модификатор
    1) static
        Методы и поля принадлежат к классу, нельзя вызывать из статических методов, нестатические методы и поля
    2) final
        класс нельзя наследовать
        метод переопределять
        поле изменять.
    3) abstract
        -   Нельзя создать объект абстрактного класса;
        -	В абстрактном классе могут быть конкретные реализации методов;
        -	Если в классе объявлен хоть один абстрактный метод, сам класс должен быть объявлен абстрактным;

Ключевое слово super
    public Cat(int a, int b) {
        super(a);        // первым делом вызываем конструктор Animal
        this.b = b;
    }

    public void test() {
        z = 10;          // Обращение к полю z класса Cat
        super.z = 20;    // Обращение к полю z класса Animal
    }

Переопределение (если имя, список аргументов и возвращаемый тип обоих методов одинаковы)
    @Override // необязательное
        void voice() {
            System.out.println("Кот мяукнул");
        }

Класс Object Все ссылочные типы являются наследниками object

public String toString() {
          return getClass().getName() + "@" + Integer.toHexString(hashCode());
 }

hashCode()
public String toString() {
      return getClass().getName() + "@" + Integer.toHexString(hashCode());
   }

При переопределении методов hashCode() и equals() необходимо обязательно придерживаться следующего:
-	Если объекты равны через метод equals(), то их hashCode() обязательно должны быть равны;
-	Если объекты не равны по equals(), то желательно чтобы их hashCode() отличались, но этого не всегда удается достичь (так как hashCode() возвращает не уникальное число)


interface

Модификатор_доступа interface имя_интерфейса {
   возвращаемый_тип имя_метода1(список_аргументов);
   возвращаемый_тип имя_метода2(список_аргументов);
   тип имя_поля1 = значение;
   тип имя_поля2 = значение;
}
Модификатор_доступа class имя_класса [extend суперкласс] [implements имя_интерфейса, ...] {
   ...
}

Перечисления !!!!!! прочитать
Массив статичных ссылок

public enum Fruit {
// Объявление
    ORANGE("Апельсин", 3),
     APPLE("Яблоко", 3), BANANA("Банан", 2), CHERRY("Вишня", 1);
    // поля перечислений
    private String russianTitle;
    private int weight;

    public String getRussianTitle() {
        return russianTitle;
    }

    public int getWeight() {
        return weight;
    }

    Fruit(String russianTitle, int weight) {
        this.russianTitle = russianTitle;
        this.weight = weight;
    }
}

public class Main {
    public static void main(String[] args) {
        for(Fruit fruit : Fruit.values()) {
            System.out.printf("Средний вес фрукта %s составляет: %d ед.\n", fruit.getRussianTitle(), fruit.getWeight());
        }
    }
}

Внутренний класс — это нестатический вложенный класс
Внешний без внутреннего может существовать,
А внутренний без внешнего нет.
Если класс не используется без чего либо
Выносим его в Внутренний класс

// обычно используется для передачи параметров во внутренние методы родителя

// редко используется.
Это как бы таблица внутри объекта
Создается внешний.внутренний имя = new внешний().new внутренний();

// Слево интерпретация, а справа реализация
TRUE ? this : this