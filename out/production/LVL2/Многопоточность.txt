многопоточный
отменяет холостой ход (во время отдачи пакета)
процессор

задание
100 ядерный 1 поток 60 секунд
при 4 потоках будет (>15 сек)


1) Запуск потока через наследование от класса Тhread
public class MyThread extends Thread {
   @Override
   public void run() {
       for (int i = 0; i < 5; i++) {
           System.out.println("Thread out: " + i);
       }
   }
}

public class MainApp {
   public static void main(String[] args) {
       Thread thread1 = new MyThread();
       Thread thread2 = new MyThread();
       thread1.start();// выполнение кода
       thread2.start();// выполнение кода в потоке
   }
}

2) Запуск потока через реализацию интерфейса Runnable

public class MyRunnableTask implements Runnable {
   @Override
   public void run() {
       for (int i = 0; i < 5; i++) {
           System.out.println("Thread out: " + i);
       }
   }
}

public class MainApp {
   public static void main(String[] args) {
       Thread thread1 = new Thread(new MyRunnableTask());
                                   // здесь отличие
       Thread thread2 = new Thread(new MyRunnableTask());
       thread1.start();
       thread2.start();
   }
}

3) Запуск потока через анонимный внутренний класс/лямбду

public class MainApp {
   public static void main(String[] args) {
       Thread thread = new Thread(new Runnable() {
           @Override
           public void run() {
               for (int i = 0; i < 5; i++) {
                   System.out.println(i);
               }
           }
       });
       thread.start();
   }
}

public class MainApp {
   public static void main(String[] args) {
       Thread thread = new Thread(() -> {
           for (int i = 0; i < 5; i++) {
               System.out.println(i);
           }
       });
       thread.start();
   }
}

4) main свой поток. Программа работает, пока работает последний поток

Управление потоком
    а) запуск потока (start);
    б) перезапуск (невозможно) IllegalThreadStateException;
    в) Получение ссылки на текущий поток
        Thread.currentThread();
    г) усыпить поток Thread.sleep(long ms);
    д) Daemon потоки (работают пока работает хотя бы 1 поток);
        Нельзя делать останавливаемый поток;
    е) Thread.getName() имя потока
    ж) thread.join();
        ожидает завершение потока (нужно присоединить все 3 потока)

Паралельные потоки
    1) Порядок выполнения кода (нельзя определить четко)
    2) Условие гонки (Race Condition)
        изменение полей идет в 2 этапа (get и set)
        может быть так что записывает в поле, когда его взяли
        ! нельзя параллельно изменять ресурс

Daemon потоки
    Связываем с основным потоком,
    как только основной поток закончит свою работу,
    ты тоже закончишь свою работу.
    Пока работает хотя бы один не демон поток


Синхронизация
    Главным для синхронизации в Java является понятие монитора,
        контролирующего доступ к объекту.
    Монитор реализует принцип блокировки.
        Если объект заблокирован одним потоком, это означает, что этот поток захватил монитор объекта.
    1) synchronized Для синхронизации нестатического метода
        public synchronized void decrement() {
               value--;
           }
    Такой вариант кода говорит о том,
    что в единицу времени у одного объекта типа Counter,
    только один поток может вызывать или метод decrement(),
    или метод increment() (т.е. только один нестатический синхронизированный метод).
    Потоки, которые попытаются сделать параллельный вызов этих методов, перейдут в режим ожидания.

Механизм wait / notify
    1)Метод wait() вынуждает вызывающий поток исполнения уступить монитор и
        перейти в состояние ожидания до тех пор, пока какой-нибудь
        другой поток не войдет в тот же монитор и не вызовет метод notify().
    2)Метод notify() возобновляет исполнение потока,
        из которого был вызван метод wait() для того же самого монитора.
    3)Метод notifyAll() возобновляет исполнение всех потоков,
        из которых был вызван метод wait() для того же самого монитора. Одному из этих потоков предоставляется доступ.
