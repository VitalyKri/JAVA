1) Массив нельзя изменять, только копировать
Массив быстрее коллекции (бинарник)

!!!!Коллекция представляет собой контейнер, который хранит в себе множество элементов,
и позволяющий работать с этой группой элементов как с одним объектом.
Коллекции используются для хранения, получения, обработки множества объектов.

●	Collection - является “корневым” элементом иерархии коллекций.
    Коллекция представляет собой группу объектов, называемых элементами.
    Интерфейс описывает функционал присущий абсолютно всем коллекциям.
●	Set - коллекция, представляющая собой множество элементов, которое не может содержать дубликаты.
●	List - коллекция, содержащая в себе последовательность элементов.
    В этом типе коллекций дубликаты разрешены.
    List позволяет обращаться к своим элементам по индексу, добавлять/изменять/удалять элементы.
●	Queue - коллекция, позволяющая управлять процессом обработки элементов.
    Как правило, работает в режиме FIFO (first-in, first-out, первый вошел - первый вышел, например, очередь в кабинет).
    В таком случае элементы добавляются в хвост, а забираются с головы.
●	Deque - коллекция, позволяющая управлять процессом обработки элементов.
    Deque может использоваться как в режиме FIFO , так и в режиме LIFO (last-in, first-out, последний вошел - первый вышел,
    например, в стопку бумаг кладут сверху листы, и оттуда же их забирают).
    Deque позволяет добавлять/изменять/удалять элементы как в голове, так и в хвосте коллекции.
●	Map, коллекция которая отображает ключ, к его значению. Map не может содержать дублирующиеся ключи.
    Map не наследуется от интерфейса Collection.
●	SortedSet и SortedMap представляют собой упорядоченные в порядке возрастания версии коллекций
    Set (сортировка идет по элементам) и Map (сортировка производится по ключам).


2)ArrayList работает только ссылками обертка над массивом
ArrayList<> (10000);
массив капасити сколько выделено, size сколько содержит
    a)размер (size) и емкость (capacity). size указывает на то,
    сколько объектов уже хранится в нем, а capacity - на сколько объектов рассчитана данная коллекция

    б)При удаление элементы смещаются вперед
    Для этого используется
    Итератор использует
    -	void add(int index, E obj): добавляет в список по индексу index объект obj
    -   boolean addAll(int index, Collection<? extends E> col): добавляет в список по индексу index все элементы коллекции col.
        Если в результате добавления список был изменен, то возвращается true, иначе возвращается false
    -   E get(int index): возвращает объект из списка по индексу index
    -   int indexOf(Object obj): возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1
    -   int lastIndexOf(Object obj): возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1
    -   ListIterator<E> listIterator (): возвращает объект ListIterator для обхода элементов списка
    -   static <E> List<E> of(элементы): создает из набора элементов объект List
    -   E remove(int index): удаляет объект из списка по индексу index, возвращая при этом удаленный объект
    -   E set(int index, E obj): присваивает значение объекта obj элементу, который находится по индексу index
    -   void sort(Comparator<? super E> comp): сортирует список с помощью компаратора comp
    -   List<E> subList(int start, int end): получает набор элементов, которые находятся в списке между индексами start и end
    ArrayList имеет следующие конструкторы:
        ArrayList(): создает пустой список
        ArrayList(Collection <? extends E> col): создает список, в который добавляются все элементы коллекции col.
        ArrayList (int capacity): создает список, который имеет начальную емкость capacity

Queue
    -   E element(): возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException
    -   boolean offer(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false
    -   E peek(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null
    -   E poll(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null
    -   E remove(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException

Deque Интерфейс
расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди,
которая работает как обычная однонаправленная очередь,
либо как стек, действующий по принципу LIFO (последний вошел - первый вышел).

LinkedList
    Структура LinkedList значительно отличается от ArrayList.
    Каждый элемент в связном списке имеет ссылку на предыдущий и на следующий элементы.
    Сам же LinkedList имеет ссылку на свой первый и последний элемент.
    Важно! В отличие от ArrayList, LinkedList не использует массивов в своей внутренней структуре.

    addFirst() / offerFirst(): добавляет элемент в начало списка
    addLast() / offerLast(): добавляет элемент в конец списка
    removeFirst() / pollFirst(): удаляет первый элемент из начала списка
    removeLast() / pollLast(): удаляет последний элемент из конца списка
    getFirst() / peekFirst(): получает первый элемент
    getLast() / peekLast(): получает последний элемент

Поиск по обходу (а не сразу обращение к элементу) LIFO и FIFO


HashМap (ключ хеш сумма, и значение) соответствие
    -   void clear(): очищает коллекцию
    -   boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
    -   boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
    -   Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
    -   boolean equals(Object obj): возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
    -   boolean isEmpty: возвращает true, если коллекция пуста
    -   V get(Object k): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
    -   V getOrDefault(Object k, V defaultValue): возвращает значение объекта, ключ которого равен k.
        Если такого элемента не окажется, то возвращается значение defaultValue
    -   V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v.
        Если в коллекции уже есть объект с подобным ключом, то он перезаписывается.
        После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции.
        Если же ключа еще не было в коллекции, то возвращается значение null
    -   V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
    -   Set<K> keySet(): возвращает набор всех ключей отображения
    -   Collection<V> values(): возвращает набор всех значений отображения
    -   void putAll(Map<? extends K, ? extends V> map): добавляет в коллекцию все объекты из отображения map
    -   V remove(Object k): удаляет объект с ключом k
    -   int size(): возвращает количество элементов коллекции
порядок по ключам
типы ключа и значения могут отличаться.
Для того, чтобы понять, что такое ключ, и что такое значение,
а также почему HashMap позволяет производить быстрый поиск значения по ключу,
необходимо немного углубиться в структуру и логику работы HashMap.
!! во время коллизии создает list list
Для использование ссылок в виде ключа, нужно переопределение иквуев и hashcode

HashSet
только значение (без дубликата) данные записываются в виде хештаблицы
из хешкода значение получить нельзя. Колизици нет

SortedMap Интерфейс расширяет Map и создает отображение,
в котором все элементы отсортированы в порядке возрастания их ключей



TreeSet<E>
    представляет структуру данных в виде дерева,
    в котором все объекты хранятся в отсортированном виде по возрастанию.
    TreeSet является наследником класса AbstractSet и реализует интерфейс NavigableSet, а следовательно, и интерфейс SortedSet.

    В классе TreeSet определены следующие конструкторы:

    TreeSet(): создает пустое дерево
    TreeSet(Collection<? extends E> col): создает дерево, в которое добавляет все элементы коллекции col
    TreeSet(SortedSet <E> set): создает дерево, в которое добавляет все элементы сортированного набора set
    TreeSet(Comparator<? super E> comparator): создает пустое дерево, где все добавляемые элементы впоследствии будут отсортированы компаратором.

// Компоратор можно описать во вне класса, как и в классе
class PersonComparator implements Comparator<Person>{

    public int compare(Person a, Person b){

        return a.getName().compareTo(b.getName());
    }
}

// как и в классе
Comparable метод сортировки дерева
public class Cat implements Comparable {
   // ...
   @Override
   public int compareTo(Object o) {
       return this.age - ((Cat)o).age;
   }
   // ...
}

public class Cat implements Comparable {
   private String name;
   private int age;

   public Cat(String name, int age) {
       this.name = name;
       this.age = age;
   }

   @Override
   public int compareTo(Object o) {
       Cat another = (Cat)o;
       if (this.age > another.age) {
           return 1;
       }
       if (this.age < another.age) {
           return -1;
       }
       return 0;
   }

   @Override
   public String toString() {
       return "Cat [" + name + "]";
   }
}

